/**
 * @author Holmes Bryant <https://github.com/HolmesBryant>
 * @version 2.0.0
 * @license MIT
 */
class t{report(t){throw new Error("ATestReporter.report() must be implemented by subclasses.")}groupStart(t){throw new Error("ATestReporter.groupStart() must be implemented by subclasses.")}groupEnd(){throw new Error("ATestReporter.groupEnd() must be implemented by subclasses.")}done(t){throw new Error("ATestReporter.done() must be implemented by subclasses.")}}class e extends t{#t(t){switch(t){case"pass":return"color:limegreen; font-weight:bold";case"fail":return"color:red; font-weight:bold";case"info":return"color:SandyBrown; font-weight:bold";case"GROUP_START":return"color:darkorange; font-weight:bold";case"error":return"color:fuchsia; font-weight:bold;";default:return"color:dodgerblue; font-weight:bold"}}report(t){const{gist:e,verdict:r,result:s,expect:n,line:i,message:o,type:u}=t;if("info"===u)return void console.log("%cINFO",this.#t("info"),o);const a=[`%c${r.toUpperCase()}`,this.#t(r),e];console.groupCollapsed(...a),console.log("Result:",s),console.log("Expected:",n),i&&console.log("Line:",i),console.groupEnd()}groupStart(t){console.group(`%c${t}`,this.#t("GROUP_START"))}groupEnd(){console.groupEnd()}done(){console.log("%cDONE",this.#t("done"))}}class r extends t{#e;#r;constructor(t,e){super(),this.#e=t,this.#r=e}#s(t){const e=new CustomEvent(this.#r,{detail:t,bubbles:!0,composed:!0});this.#e.dispatchEvent(e)}#n(t){const{gist:e,verdict:r,result:s,expect:n,line:i,message:o,type:u}=t,a="info"===u?{gist:o,verdict:"INFO"}:{gist:e,verdict:r.toUpperCase(),result:s,expect:n,line:i};return a.result instanceof Error&&(a.result=a.result.stack?a.result.stack.split("\n"):a.result.message),a}report(t){const e=this.#n(t);this.#s(e)}groupStart(t){this.#s({gist:t,verdict:"GROUP_START"})}groupEnd(){this.#s({gist:null,verdict:"GROUP_END"})}done(){}}class s{currentLine=null;onlyFailed=!1;timeout=2e3;resultEventName="a-testresult";progressEventName="a-progress";completeEventName="a-complete";#i=Promise.resolve();#o="pass";#u;#a="console";#c=[];#l;constructor(t){this.#u=t,this.#l=new e,this.group=this.group.bind(this),this.info=this.info.bind(this),this.skip=this.skip.bind(this),this.test=this.test.bind(this),this.when=this.when.bind(this),this.profile=this.profile.bind(this),this.run=this.run.bind(this)}async benchmark(t,e=1,r=null,...s){const n=performance.now();for(let n=0;n<e;n++)await t.apply(r,s);return performance.now()-n}equal(t,e){const r=new Map;return function t(e,s){if(e===s)return!0;if(null===e||"object"!=typeof e||null===s||"object"!=typeof s)return!1;if(r.has(e)&&r.get(e)===s)return!0;if(r.set(e,s),Object.getPrototypeOf(e)!==Object.getPrototypeOf(s))return!1;if(e instanceof Date)return e.getTime()===s.getTime();if(e instanceof RegExp)return e.toString()===s.toString();if(e instanceof ArrayBuffer||ArrayBuffer.isView(e)){if(e.byteLength!==s.byteLength)return!1;const t=new Uint8Array(e.buffer,e.byteOffset,e.byteLength),r=new Uint8Array(s.buffer,s.byteOffset,s.byteLength);for(let s=0;s<e.byteLength;s++)if(t[s]!==r[s])return!1;return!0}if(e instanceof Map){if(e.size!==s.size)return!1;for(const[r,n]of e)if(!s.has(r)||!t(n,s.get(r)))return!1;return!0}if(e instanceof Set){if(e.size!==s.size)return!1;const r=[...s];for(const s of e){const e=r.findIndex(e=>t(s,e));if(-1===e)return!1;r.splice(e,1)}return!0}if(Array.isArray(e)){if(e.length!==s.length)return!1;for(let r=0;r<e.length;r++)if(!t(e[r],s[r]))return!1;return!0}const n=Object.keys(e);if(n.length!==Object.keys(s).length)return!1;for(const r of n)if(!Object.prototype.hasOwnProperty.call(s,r)||!t(e[r],s[r]))return!1;return!0}(t,e)}*genCombos(t={}){const e=Object.keys(t),r=Object.values(t);yield*function*t(s,n){if(s===e.length)return void(yield{...n});const i=e[s],o=r[s];if(Array.isArray(o))for(const e of o)n[i]=e,yield*t(s+1,n);else n[i]=o,yield*t(s+1,n)}(0,{})}group(t,e){this.#i=this.#i.then(async()=>{this.#c.push({type:"group_start",payload:{gist:t}}),await e(),this.#c.push({type:"group_end",payload:{}})})}handleError(t,e={}){let r;const s=e.code??null,n=e.line??this.currentLine??(this.#u?this.#h():null);r=e.gist?e.gist:s?`Failed to execute:\n${s}`:"Error during setup",this.#c.push({type:"test",payload:{gist:r,testFn:t,expect:null,line:n,verdict:"error"}})}info(t){this.#c.push({type:"info",payload:{message:t}})}async profile(t,e,r=this,...s){let n=this[t];return n||("executeTest"===t?n=this.#p:"getLine"===t&&(n=this.#h)),this.benchmark(n,e,r,...s)}async run(){await this.#i,this.#f(0,this.#c.length),await this.#d(),this.#l.done(this.#o),this.#g()}skip(t,e,r){const s=this.currentLine??(this.#u?this.#h():null);this.#c.push({type:"skip",payload:{gist:t,testFn:e,expect:r,line:s,verdict:"skip"}})}spyOn(t,e){const r=t[e];if("function"!=typeof r)throw new Error(`${e} is not a function`);const s={callCount:0,calls:[],restore:()=>{t[e]=r}};return t[e]=function(...t){return s.callCount++,s.calls.push(t),r.apply(this,t)},s}test(t,e,r,s={}){const n={gist:t,testFn:e,expect:r,line:this.currentLine??(this.#u?this.#h():null),...s};this.#c.push({type:"test",payload:n})}throws(t,...e){try{return t(...e),!1}catch(t){return!0}}async wait(t){return new Promise(e=>setTimeout(e,t))}async when(t,e=1e3,r=100){const s=Date.now();let n="function"==typeof t?async()=>t():async()=>t;for(;;){if(Date.now()-s>=e)return await n();try{const t=await n();if(t)return t}catch(t){throw t}await this.wait(r)}}#y(t){this.#i=this.#i.then(t)}#m(t){return"info"===t.type?Promise.resolve({type:"info",message:t.payload.message}):this.#p(t.payload)}async#p(t){const{gist:e,testFn:r,expect:s,line:n,verdict:i,timeout:o}=t,u=o??this.timeout;try{if(i){return{type:"test",gist:e,verdict:i,result:"error"===i?r:"Not executed",expect:s,line:n}}const t=new Promise((t,e)=>setTimeout(()=>e(new Error(`Test timed out after ${u}ms`)),u)),o=(async()=>{const t="function"==typeof r?r():r;if(t instanceof Error)return{type:"test",gist:e,verdict:"error",result:t,expect:s,line:n};const i=await t,o=this.equal(i,s)?"pass":"fail";return{type:"test",gist:e,verdict:o,result:i,expect:s,line:n}})();return await Promise.race([o,t])}catch(t){return{type:"test",gist:e,verdict:"error",result:t,expect:s,line:n}}}#h(){try{throw Error("")}catch(t){if(!t.stack)return null;const e=t.stack.split("\n").find(t=>t.includes(this.#u));if(!e)return null;const r=e.indexOf(this.#u)+this.#u.length+1,s=e.lastIndexOf(":");return e.substring(r,s)}}async#d(){const t=[[]];let e=!1;for(const[r,s]of this.#c.entries()){switch(s.type){case"group_start":this.#l.groupStart(s.payload.gist),e=!0;break;case"group_end":const r=t[t.length-1];await this.#w(r),r.length=0,this.#l.groupEnd(),e=!1;break;default:const n=this.#m(s);if(e)t[t.length-1].push(n);else{const t=await n;this.#b(t)}}this.#f(r+1,this.#c.length)}}async#w(t){const e=await Promise.all(t);for(const t of e)this.#b(t)}#b(t){"fail"!==t.verdict&&"error"!==t.verdict||(this.#o="fail"),this.onlyFailed&&"pass"===t.verdict||this.#l.report(t)}#g(){const t=this.#a.dispatchEvent?this.#a:document,e=new CustomEvent(this.completeEventName,{detail:{verdict:this.#o}});t.dispatchEvent(e)}#f(t,e){const r=this.#a.dispatchEvent?this.#a:document,s=new ProgressEvent(this.progressEventName,{lengthComputable:!0,loaded:t,total:e});r.dispatchEvent(s)}get output(){return this.#a}set output(t){if("console"===t)return this.#l=new e,void(this.#a="console");let s;if(t instanceof HTMLElement?s=t:"string"==typeof t&&(s=document.querySelector(t)),!s)throw new Error(`Cannot find output target: ${t}`);this.#l=new r(s,this.resultEventName),this.#a=s}get finalVerdict(){return this.#o}}export{s as default};
